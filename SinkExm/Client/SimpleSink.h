// SimpleSink.h - a header with two templates to allow COM clients
// to handle events from COM objects in the easiest possible way,
// without using ATL, or any other library.
// Author: Vitaly Tomilov. Email: Vitaly@Cylon.ie
// 10/08/2001
// **************************************************************

#ifndef _SimpleSink
#define _SimpleSink

#include "comdef.h"

// CSimpleSink implements IUnknown in the simplest way to allow clients
// to handle events coming from a custom event interface,
// and an easy approach to use connection points.

// Parameters:
// "LibID" - a GUID pointer of the type library
// "Interface_ID" - a GUID pointer of the interface that implements
// the connection point
// "EventClass" - Name of the custom event interface

// Example:
// class MySink: public CSimpleSink<LIBID_MYSERVERLib, IID_IMyServer, _IMyServerEvents>

// Inside of MySink all event handlers will need to have exactly the same
// names and parameters as those generated by VC++ when the type library
// is imported into the project, which makes it easy to control function names
// and parameters correctness. The only disadvantage is that you will have
// to implement all virtual functions to instantiate such a class.

template<const IID * LibID, const IID * Interface_ID, class EventClass>
class CSimpleSink:public EventClass
{
public:
	CSimpleSink()
	{
		m_cookie = -1; // The object is not connected to anything
	}
	~CSimpleSink()
	{
		Disconnect();	// Disconnecting, if were connected
	}

	// We do not need to count references,
	// because all we need is just to handle events.
	// Therefore, we always assume only one reference.
	STDMETHOD_(ULONG,AddRef)(){return 1;}
	STDMETHOD_(ULONG,Release)(){return 1;}

    // The same, no complexity needed when this class is just
	// to handle events:
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppv)
    { 
        if ((iid == __uuidof(EventClass)) || (iid == __uuidof(IDispatch)) || (iid == __uuidof(IUnknown)))
            *ppv = this;
        else
        {
            *ppv = 0;
            return E_NOINTERFACE;
        }
        return S_OK;
    }

// Connecting this object to a connection point container
	void Connect(IConnectionPointContainerPtr container)
	{
		Disconnect(); // Disconnect, if has been connected

		// First, we find the connection point
		container->FindConnectionPoint(__uuidof(EventClass), &m_cpoint);

		// Then we advertise this class's ability to handle events
		m_cpoint->Advise(this, &m_cookie);
	}

// This method disconnects the object, if it has been connected
	void Disconnect()
	{
		if(m_cookie != -1)
		{
			m_cpoint->Unadvise(m_cookie);	// Unadvise the connection
			m_cpoint.Release();				// Release the connection point
			m_cookie = -1;					// Indicate no connection.
		}
	}

private:

	IConnectionPointPtr m_cpoint;
	DWORD m_cookie;
};

// CSimpleDispSink
// The only difference from CSimpleSink is that it allows handling events
// coming from an event interface that implements IDispatch.
// In this situation you do not need to implement all virtual functions when
// you need just one.
// It yet has one disadvantage. It doesn't control the way you declare
// your event handlers, which means that not only wrongly declared parameters,
// but also a wrong sequence of the event handlers will cause wrong invocation.
// See the Invoke method.
// You also need to specify the type library version and locale for the constructor,
// or call InitDispSink afterwards.

template<const IID * LibID, const IID * Interface_ID, class EventClass>
class CSimpleDispSink:public CSimpleSink<LibID, Interface_ID, EventClass>
{
public:
	CSimpleDispSink(int wVerMajor, int wVerMinor, LCID lcid = 0)
	{
		m_tinfo = NULL;
		InitDispSink(wVerMajor, wVerMinor, lcid);
	}
	
	CSimpleDispSink()
	{
		m_tinfo = NULL;
	}

	bool InitDispSink(int wVerMajor, int wVerMinor, LCID lcid = 0)
	{
		if(m_tinfo)
			return false;

		ITypeLib * ptlib; // Type library

		// Loading the type library from the Windows registry:
		if(LoadRegTypeLib(*LibID, wVerMajor, wVerMinor, lcid, &ptlib) == S_OK)
		{
			// Get type information for interface of the object.
			ptlib->GetTypeInfoOfGuid(*Interface_ID, &m_tinfo);
	
			// Release the type library
			ptlib->Release();
			
			return true;
		}

		return false;
	}

	// We do not need to return any type information when all we need
	// is just to handle events:
	STDMETHOD(GetTypeInfoCount)(UINT*){return E_NOTIMPL;}
	STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo**){return E_NOTIMPL;}
	STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, UINT, LCID, DISPID*){return E_NOTIMPL;}

	// This method will be invoked by the COM server to find and call your event handler.
	// The Sink object is supposed to have a handler in the right place and with the
	// right parameters:
	STDMETHOD(Invoke)(DISPID p1, REFIID p2, LCID p3, WORD p4, DISPPARAMS* p5, VARIANT* p6, EXCEPINFO* p7, UINT* p8)
	{
		return m_tinfo?m_tinfo->Invoke(this, p1, p4, p5, p6, p7, p8):E_NOTIMPL;
	}

private:
	ITypeInfo * m_tinfo;
};

#endif
